import X_PP_IB_HNDLR_X:StringBuffer;
import PT_SECURITY:OAuth2:*;

class ServiceIntegration
   method ServiceIntegration();
   /* Fetch Config */
   method fetchConfig();
   /* Set path */
   method setDirectory(&sUserDir_ As string);
   /* FindFiles in a directory */
   method retrieveFiles(&sFileStor_ As string, &sAbsRelPath_ As boolean) Returns array of string;
   /* Upload a file to construct multipart/form-data */
   method uploadAttachment() Returns number;
   /* Call Svc Endpoint */
   method callService(&arrHdr#_ As array of string, &arrBody#_ As array of string, &sFileUpload_ As string) Returns array of string;
   /* Parse Svc Response */
   method parseSvcResponse(&sJSONResp_ As string);
   /* Logging and debugging methods */
   method logRequest(&function As string, &request As string);
   method logPollSpanTime(&sMethodName_ As string, &startTime_ As time, &endTime_ As time);
   method debug(&sText As string);
   /* Regex methods */
   method getCombineRegExp() Returns string;
   method regexPattern(&sInput_ As string) Returns boolean;
   /* Delete File */
   method FileDelete(&strFilePath_ As string);
   /* Regenerate File */
   method regenerateFile(&sUserFileName_ As string);
   /* Remove Directory */
   method cleanup();
   
   property string sGUID_;
   property string sSvcRespPayload_;
   property string sPathSeparator_;
   property string sUserFilePath_;
   property string sSysFileName_;
   property string sFileUploadDir_;
   property string sBASE64FileData_;
   property boolean bCallSvc_;
   
private
   
   /* UNIX or Windows */
   method getPathSeparator();
   /* Directory Methods */
   method transferAttachment();
   method addForwardSlash(&sDirStr_ As string) Returns string;
   method addBackSlash(&sDirStr_ As string) Returns string;
   method findAddSlash(&sDirStr_ As string) Returns string;
   method ensureDirectoryHasTrailingSlash(&sDirStr_ As string) Returns string;
   /* Set Authorisation */
   method buildAuth(&arrSecurity_ As array of string);
   /* Build Headers */
   method buildHeader(&arrHdr_ As array of string);
   /* Build Body */
   method buildBody(&sMultipartBody_ As string, &MultipartBoundary_ As string, &arrBody_ As array of string) Returns string;
   /* JSON Parser */
   method getJSONParser(&content_ As string) Returns JsonObject;
   /* File Extension and MIME */
   method getFileExtension(&sAttachFileName_ As string) Returns string;
   method getContentType(&sFileExtension_ As string) Returns string;
   /* Convert file to BASE64 encoded string */
   method binaryToBase64(&oReceiptFile_ As string, &sFilePath_ As string) Returns string;
   /* Log to File/db */
   method logSvcResponse(&sPSPayloadBody_ As string) Returns boolean;
   /* Evaluate NodeType */
   method evalNodeType(&oEvalJS_ As JsonObject, &sNodeName_ As string, &sPath_ As string, &nCount_ As number) Returns string;
   /* Store JSON in DB */
   method logJSONToDB();
   /* JSONPath */
   method getJSONPath(&oEvalJS_ As JsonObject, &sSelNodeName_ As string, &sNodePath_ As string);
   method ensureJSONPathHasLeadingDollar(&sJSONPathVal_ As string) Returns string;
   /* Store value-value pair based on JSONPath */
   method logKVP();
   method cleanArrays(&arrClean_ As array of array of string);
   
   instance string &sBoundary_;
   instance string &sSvcResponse_;
   instance string &sCRLF_;
   instance string &sUploadedFile_;
   instance string &sArrVarName_;
   instance string &sEvalNodeType_;
   instance string &sEndpointURL_;
   instance string &sPSServDir_;
   instance string &sPSFileDir_;
   instance string &sLocalURL_;
   instance string &sServiceApplication_;
   instance PTDirectTransferObject &oPTDirTrf_; /* Has a hard tools dependency */
   instance array of array of any &arrKeyValue_;
   instance array of array of string &arrJsonPath_;
   instance number &n2DArrCnt_;
   rem instance string &sPath_;
   
   instance X_PP_IB_HNDLR_X:StringBuffer &oStringBuffer_;
   instance X_PP_IB_HNDLR_X:StringBuffer &oAppend_;
   
   Constant &sSvcURL_ = "YOUR URI";
   /* These should be passed by the client app */
   Constant &sExpAppID_ = "appId: SOMETHING";
   Constant &sTenantID_ = "tenantId: test";
   Constant &sYOUREngineName_ = "YOUR ENGINE NAME";
   /* Constants for Header and Body */
   Constant &sContentLength_ = "Content-Length: ";
   Constant &sMultipartFormData_ = "Content-Type: multipart/form-data; boundary=";
   Constant &sContentTransferEncoding_ = "Content-Transfer-Encoding: ";
   Constant &sEncoding_ = "BASE64"; /* case-insensitive */
   Constant &sContentDisposition_ = "Content-Disposition: form-data; name=";
   Constant &sGenContentType_ = "Content-Type: ";
   Constant &sMethod_ = "POST";
   Constant &sHTTP_ = "http://";
   Constant &sHTTPS_ = "https://";
   Constant &sStardotStar_ = "*.*";
   /* For JSONPath */
   Constant &sRoot_ = "$";
   Constant &sCurrObj_ = "@";
   Constant &sDotChild_ = ".";
   Constant &bDebug_ = True; /* Change this to True for debugging */
   
end-class;

Component array of array of string &arrReturnValues_;

method ServiceIntegration
   
   &sCRLF_ = Char(13) | Char(10);
   If GetEnv("PS_FILEDIR") = "" And
         GetEnv("PS_SERVDIR") = "" Then
      MessageBox(0, "", 158, 4096, "Environment variables PS_FILEDIR and PS_SERVDIR are not set.");
   Else
      &sPSServDir_ = GetEnv("PS_SERVDIR");
      &sPSFileDir_ = GetEnv("PS_FILEDIR");
   End-If;
   If &arrKeyValue_ = Null Then
      &arrKeyValue_ = CreateArrayRept(CreateArrayAny(), 0);
   End-If;
   If &arrJsonPath_ = Null Then
      &arrJsonPath_ = CreateArrayRept(CreateArrayRept("", 0), 0);
   End-If;
   If &arrReturnValues_ = Null Then
      &arrReturnValues_ = CreateArrayRept(CreateArray("", 0), 0)
   End-If;
   rem &sPath_ = &sRoot_;
   If %This.sPathSeparator_ = "" Then
      %This.getPathSeparator();
   End-If;
   %This.sSysFileName_ = "";
   rem %This.sFileUploadDir_ = "";
   %This.sGUID_ = "";
   %This.sSvcRespPayload_ = "";
   %This.bCallSvc_ = False;
   If (%This.sFileUploadDir_ = "") Then
      %This.setDirectory("");
   End-If;
   
end-method;

method setDirectory
   /+ &sUserDir_ as String +/
   
   Local string &sLocalDir_;
   rem Substitute(UuidGen(), "-", "");
   /* Get a unique identifier to be used as the directory name so that only the current run locks those files */
   If All(&sUserDir_) Then
      &sLocalDir_ = &sUserDir_;
      &sLocalDir_ = %This.ensureDirectoryHasTrailingSlash(&sLocalDir_);
      REM *** Construct Directory Path ***;
      %This.sFileUploadDir_ = %This.ensureDirectoryHasTrailingSlash(&sLocalDir_ | UuidGen());
   Else /* Default to PS_SERVDIR */
      &sLocalDir_ = %This.ensureDirectoryHasTrailingSlash(&sPSServDir_);
      REM *** Construct Directory Path ***;
      %This.sFileUploadDir_ = %This.ensureDirectoryHasTrailingSlash(&sLocalDir_ | "files" | %This.sPathSeparator_ | UuidGen());
   End-If;
   %This.debug("Working Directory : " | %This.sFileUploadDir_);
   rem %This.debug("GetCwd() " | GetCwd());
   REM *** Make sure you clean the directory ***;
   rem RemoveDirectory(%This.sFileUploadDir_, %FilePath_Absolute + %Remove_Subtree);
   REM *** Create a fresh directory ***;
   CreateDirectory(%This.sFileUploadDir_, %FilePath_Absolute);
   
end-method;

method cleanup
   
   try
      REM *** Make sure you clean the directory ***;
      RemoveDirectory(%This.sFileUploadDir_, %FilePath_Absolute + %Remove_Subtree);
      %This.debug("Working Directory : " | %This.sFileUploadDir_ | " removed");
   catch Exception &errRmDir_
      Error ("Error: " | &errRmDir_.ToString() | " -- " | " Error when removing temporary directory: " | %This.sFileUploadDir_);
   end-try;
   
end-method;

/*
 * Configure JWT Assertion
 * Setup psft client
 * Pass token to IDCS.
 * DOES NOT WORK yet.
 */
method buildAuth
   /+ &arrSecurity_ as Array of String +/
   
   Local integer &iAuth_, &iOption_;
   Local string &sToken_;
   Local PT_SECURITY:OAuth2:SEC_AUTHTOKEN &oOAuth2_;
   
   rem &iAuth_ = &oPTDirTrf_.SetAuth("<user>:<password>");
   &oOAuth2_ = create PT_SECURITY:OAuth2:SEC_AUTHTOKEN();
   /* You shouldn't be requesting a new token for each call (Batch) */
   &sToken_ = "Bearer " | &oOAuth2_.GetAccessToken(&sServiceApplication_);
   %This.debug("buildAuth " | &sToken_);
   rem &iOption_ = &oPTDirTrf_.SetOption("XOAUTH2_BEARER", "1ab9cb22ba269a7");
   &iOption_ = &oPTDirTrf_.SetOption("XOAUTH2_BEARER", &sToken_);
   
end-method;

/*
 * Accepts as many parameters as you push.
 * Content-Length is NOT added to the Header.
 */
method buildHeader
   /+ &arrHdr_ as Array of String +/
   
   Local number &nArrLen_, &nArrIndex_;
   Local integer &iAddHdr_;
   
   &nArrLen_ = &arrHdr_.Len;
   &sBoundary_ = GetJavaClass("java.util.UUID").randomUUID().toString();
   %This.sGUID_ = &sBoundary_;
   %This.debug("Unique Boundary : " | &sBoundary_);
   
   If (&nArrLen_ > 0) Then
      &nArrIndex_ = 0;
      While &arrHdr_.Next(&nArrIndex_);
         &sArrVarName_ = &arrHdr_ [&nArrIndex_];
         %This.debug("Header : " | &nArrIndex_ | " : Value : " | &sArrVarName_);
         &iAddHdr_ = &oPTDirTrf_.SetHeader(&sArrVarName_);
      End-While;
      %This.debug("Header : " | &sMultipartFormData_ | &sBoundary_);
      &iAddHdr_ = &oPTDirTrf_.SetHeader(&sMultipartFormData_ | &sBoundary_);
   Else
      %This.debug("Invalid Header Array.");
   End-If;
   
end-method;

/*
 * Method assumes body array element 2 to be a file.
 * It currently supports ONLY 2 parameters.
 */
method buildBody
   /+ &sMultipartBody_ as String, +/
   /+ &MultipartBoundary_ as String, +/
   /+ &arrBody_ as Array of String +/
   /+ Returns String +/
   
   Local string &sPayloadBody_, &sFileExtsn_, &sFileContType_, &sBASE64_;
   &oStringBuffer_ = create X_PP_IB_HNDLR_X:StringBuffer(&sMultipartBody_);
   If &arrBody_.Len > 0 Then
      &sFileExtsn_ = %This.getFileExtension(%This.sSysFileName_);
      If All(&sFileExtsn_) Then
         &sFileContType_ = %This.getContentType(&sFileExtsn_);
         &sBASE64_ = %This.binaryToBase64(%This.sSysFileName_, "");
         If All(&sBASE64_) Then
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            &oAppend_ = &oStringBuffer_.Append("--");
            &oAppend_ = &oStringBuffer_.Append(&MultipartBoundary_);
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            <* &oAppend_ = &oStringBuffer_.Append("Content-Disposition: form-data; name=""engine"""); *>
            <* &oAppend_ = &oStringBuffer_.Append(&sContentDisposition_ | """engine"""); *>
            &oAppend_ = &oStringBuffer_.Append(&sContentDisposition_ | """" | &arrBody_ [1] | """");
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            &oAppend_ = &oStringBuffer_.Append(&sYOUREngineName_);
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            &oAppend_ = &oStringBuffer_.Append("--");
            &oAppend_ = &oStringBuffer_.Append(&MultipartBoundary_);
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            <* &oAppend_ = &oStringBuffer_.Append("Content-Disposition: form-data; name=""documentFile"""); *>
            <* &oAppend_ = &oStringBuffer_.Append(&sContentDisposition_ | """documentFile"""); *>
            &oAppend_ = &oStringBuffer_.Append(&sContentDisposition_ | """" | &arrBody_ [2] | """");
            &oAppend_ = &oStringBuffer_.Append(";");
            &oAppend_ = &oStringBuffer_.Append(" filename=""" | %This.sSysFileName_ | """");
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            rem &oAppend_ = &oStringBuffer_.Append("Content-Type: " | &sFileContType_);
            &oAppend_ = &oStringBuffer_.Append(&sGenContentType_ | &sFileContType_);
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            rem &oAppend_ = &oStringBuffer_.Append("Content-Transfer-Encoding: BASE64");
            &oAppend_ = &oStringBuffer_.Append(&sContentTransferEncoding_ | &sEncoding_);
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            &oAppend_ = &oStringBuffer_.Append(&sBASE64_);
            &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            &oAppend_ = &oStringBuffer_.Append("--");
            &oAppend_ = &oStringBuffer_.Append(&MultipartBoundary_);
            &oAppend_ = &oStringBuffer_.Append("--");
            rem &oAppend_ = &oStringBuffer_.Append(&sCRLF_);
            &sPayloadBody_ = &oAppend_.Value;
            rem %This.debug("");
            %This.debug("Body : " | &sPayloadBody_);
            Return &sPayloadBody_;
         Else
            %This.logRequest(" BASE64 conversion failed for : " | %This.sSysFileName_, "");
            %This.debug("BASE64 conversion failed for : " | %This.sSysFileName_);
            Return "";
         End-If; /* BASE64 Encoding */
      Else
         %This.logRequest(" Unable to build multipart/form-data for : " | %This.sSysFileName_, "");
         %This.debug("Unable to build multipart/form-data for : " | %This.sSysFileName_);
         Return "";
      End-If; /* File Extension */
   Else
      %This.logRequest(" Invalid Body Array", "");
      rem %This.debug("");
      %This.debug("Invalid Body Array.");
      Return "";
   End-If;
   
end-method;

/*
 * Retrieve Service Endpoint details.
 * It should also store JSONPath of the "value" that you want to retrieve.
 */
method fetchConfig
   
   Local string &sSvcInstanceName_, &sServerHost_, &sSvcURI_, &sMethodName_, &sSvcApp_, &xlatTask_;
   Local number &nServerPort_;
   Local SQL &sqlSvcDefInst_ = CreateSQL("%SelectAll(:1) WHERE 1 = 1 AND DEFAULT_INSTANCE = 'Y'", Record.EX_SVC_INSTANCE);
   Local Record &recSvcConfig_ = CreateRecord(Record.EX_SVC_INSTANCE);
   
   &sMethodName_ = "ServiceIntegration:fetchConfig";
   While &sqlSvcDefInst_.Fetch(&recSvcConfig_)
      &sSvcInstanceName_ = &recSvcConfig_.INSTANCE_NAME.Value;
      &sServerHost_ = &recSvcConfig_.HOSTNAME.Value;
      &nServerPort_ = &recSvcConfig_.PORT_NUM.Value;
      &sSvcURI_ = &recSvcConfig_.TASK_URI.Value;
      rem &sYOUREngineName_ = &recSvcConfig_.ENGINE_NAME.Value;
      rem &sYOUREmailEngineName_ = &recSvcConfig_.EMAIL_ENGINE_NAME.Value;
      rem &sSvcApp_ = &recSvcConfig_..Value; /* From IB with JWT Assertion */
   End-While;
   &sqlSvcDefInst_.Close();
   If All(&sServerHost_) Then
      If All(&sSvcURI_) Then
         &sEndpointURL_ = &sHTTPS_ | &sServerHost_ | ":" | &nServerPort_ | &sSvcURI_;
         &sServiceApplication_ = &sSvcApp_;
         rem %This.debug("");
         %This.debug("Endpoint URL : " | &sEndpointURL_ | " : OAuth2 Name : " | &sServiceApplication_);
      Else
         rem TASK not supported;
         %This.logRequest(&sMethodName_ | " PeopleSoft DOES NOT support TASK.", "");
      End-If; /* SvcURI */
   Else
      rem SVC instance NOT defined;
      %This.logRequest(&sMethodName_ | " No default SVC instance defined.", "");
      %This.debug("");
      %This.debug("No default SVC instance defined!");
   End-If; /* SvcHost */
end-method;

method retrieveFiles
   /+ &sFileStor_ as String, +/
   /+ &sAbsRelPath_ as Boolean +/
   /+ Returns Array of String +/
   
   Local array of string &sFiles_;
   Local string &sDirFile_;
   
   Evaluate &sAbsRelPath_
   When = True /* Absolute */
      If All(&sFileStor_) Then
         rem %This.sUserFilePath_ = &sFileStor_ | %This.sPathSeparator_;
         %This.sUserFilePath_ = %This.ensureDirectoryHasTrailingSlash(&sFileStor_);
         &sDirFile_ = %This.ensureDirectoryHasTrailingSlash(&sFileStor_) | &sStardotStar_;
         &sFiles_ = FindFiles(&sDirFile_, %FilePath_Absolute);
         %This.debug(&sAbsRelPath_ | " File Storage Path : " | &sDirFile_ | " FindFiles Absolute!");
      Else
         %This.sUserFilePath_ = &sPSServDir_ | %This.sPathSeparator_ | "files" | %This.sPathSeparator_;
         &sDirFile_ = &sPSServDir_ | %This.sPathSeparator_ | "files" | %This.sPathSeparator_ | &sStardotStar_;
         &sFiles_ = FindFiles(&sDirFile_, %FilePath_Absolute);
         %This.debug(&sAbsRelPath_ | " File Storage Path : " | &sDirFile_ | " FindFiles Absolute!");
      End-If;
      Break;
   When = False /* Relative */
      If All(&sFileStor_) Then
         rem %This.sUserFilePath_ = &sFileStor_ | %This.sPathSeparator_;
         %This.sUserFilePath_ = %This.ensureDirectoryHasTrailingSlash(&sFileStor_);
         &sDirFile_ = %This.ensureDirectoryHasTrailingSlash(&sFileStor_) | &sStardotStar_;
         &sFiles_ = FindFiles(&sDirFile_, %FilePath_Relative);
         %This.debug(&sAbsRelPath_ | " File Storage Path : " | &sDirFile_ | " FindFiles Relative!");
      Else
         %This.sUserFilePath_ = &sPSServDir_ | %This.sPathSeparator_ | "files" | %This.sPathSeparator_;
         &sDirFile_ = &sPSServDir_ | %This.sPathSeparator_ | "files" | %This.sPathSeparator_ | &sStardotStar_;
         &sFiles_ = FindFiles(&sDirFile_, %FilePath_Relative);
         %This.debug(&sAbsRelPath_ | " File Storage Path : " | &sDirFile_ | " FindFiles Relative!");
      End-If;
      Break;
   When-Other;
      &sFiles_ = Null;
      Break;
   End-Evaluate;
   
   Return &sFiles_;
   
end-method;

method uploadAttachment
   /+ Returns Number +/
   
   REM This method is only required for testing. EX is responsible for storing attachments that it pulls/downloads from Twilio Server;
   Local string &sMethodName_, &sFileName_, &sFilePathAndName_;
   Local integer &iRetCode_, &iRetCodePut_;
   
   &sMethodName_ = "ServiceIntegration:uploadAttachment";
   Local time &startTime_ = %PerfTime;
   rem Use PSFILE_ATTDET;
   &sLocalURL_ = "RECORD://X_PPXML_ATT_X";
   
   try
      &iRetCode_ = AddAttachment(&sLocalURL_, "", "", &sFileName_, 0); /* Upload file */
      &sUploadedFile_ = &sFileName_; /* Use a local variable and it must not be specified as a string constant. */
      %This.sSysFileName_ = &sFileName_;
   catch Exception &eAddAtt_
      %This.debug("Error : " | &eAddAtt_.ToString());
   end-try;
   If &iRetCode_ <> %Attachment_Success Then /* Check return code (integer or constant) */
      Exit;
   End-If;
   
   try
      &iRetCode_ = GetAttachment(&sLocalURL_, &sUploadedFile_, "", "PS_FILEDIR"); /* Get the uploaded file */
      %This.debug("File : " | &sUploadedFile_ | " uploaded : " | &sPSFileDir_);
      rem &iRetCodePut_ = PutAttachment(&sLocalURL_, &sUploadedFile_, &sUploadedFile_, "PS_FILEDIR");
   catch Exception &error_
      rem %This.debug("");
      rem This works;
      rem &iRetCode_ = GetAttachment(&sLocalURL_, &sUploadedFile_, %This.sPathSeparator_ | "files" | %This.sPathSeparator_ | &sUploadedFile_, "PS_SERVDIR");
      rem Testing new folder code;
      &sFilePathAndName_ = %This.sFileUploadDir_ | &sUploadedFile_;
      &iRetCode_ = GetAttachment(&sLocalURL_, &sUploadedFile_, &sFilePathAndName_);
      %This.debug("File : " | &sUploadedFile_ | " uploaded : " | %This.sFileUploadDir_);
      /* Copy the source file to the attachment record */
      rem &iRetCodePut_ = PutAttachment(&sLocalURL_, &sUploadedFile_, %This.sPathSeparator_ | "files" | %This.sPathSeparator_ | "PA/" | &sUploadedFile_, "PS_SERVDIR");
   end-try;
   
   Local time &endTime_ = %PerfTime;
   %This.logPollSpanTime(&sMethodName_, &startTime_, &endTime_);
   
   If &iRetCode_ <> %Attachment_Success Then
      %This.debug("");
      MessageBox(0, "", 158, 653, "Error retrieving file from database");
      %This.debug("Error retrieving file from database");
      Exit;
   End-If;
   
   Return &iRetCode_;
   
end-method;

/*
 * Download a file from its source storage location 
 * to the file system of the application server/process scheduler. 
 */
method transferAttachment
   
   Local string &sFilePathAndName_, &sUserFile_, &sAttachURL_;
   Local integer &iRetCode_, &iRetCodePut_;
   
   &sFilePathAndName_ = %This.sUserFilePath_ | %This.sSysFileName_; /* User Path */
   &sUserFile_ = %This.sSysFileName_;
   &sAttachURL_ = "RECORD://X_PPXML_ATT_X";
   %This.debug("transferAttachment" | " CurrDirAndFile : " | &sFilePathAndName_);
   try
      &iRetCode_ = GetAttachment(&sAttachURL_, &sUserFile_, %This.sFileUploadDir_ | %This.sSysFileName_);
      %This.debug("transferAttachment : " | &iRetCode_ | " NewDirAndFile : " | %This.sFileUploadDir_ | %This.sSysFileName_);
      If Not %Attachment_Success = &iRetCode_ Then
         %This.debug("GetAttachment Failed for File : " | %This.sSysFileName_ | " with code : " | &iRetCode_);
         %This.logRequest("GetAttachment Failed for File : " | %This.sSysFileName_ | " with code : " | &iRetCode_, "");
      End-If;
   catch Exception &errTrfAttach_
      %This.debug("Error : " | &errTrfAttach_.ToString());
   end-try;
   <* 
   If &iRetCode_ = 0 Then
      &sFilePathAndName_ = %This.sFileUploadDir_ | %This.sSysFileName_; /* System Path */
      &iRetCodePut_ = PutAttachment(&sAttachURL_, &sUserFile_, &sFilePathAndName_);
   Else
      %This.debug("Unable to transfer attachments");
      %This.logRequest("Unable to transfer attachments", "");
   End-If;
   *>
end-method;

/*
 * For the file extension, retrieve Content-Type.
 */
method getContentType
   /+ &sFileExtension_ as String +/
   /+ Returns String +/
   
   Local Rowset &rsMimeTable_;
   Local string &sContentType_;
   /* Query MIME mapping table to get content-type based on file extension. Lowers the file extension before searching */
   &rsMimeTable_ = CreateRowset(Record.PTFILE_MIMEMAP);
   &rsMimeTable_.Fill("WHERE FILEEXTN  =:1", Lower(&sFileExtension_));
   &sContentType_ = &rsMimeTable_(1).PTFILE_MIMEMAP.CONTENT_TYPE.Value;
   If All(&sContentType_) Then
      %This.debug("Content-Type of the file : " | &sContentType_);
   Else
      %This.debug("No matching Content-Type for File Extension : " | Lower(&sFileExtension_));
      %This.logRequest("No matching Content-Type for File Extension : " | Lower(&sFileExtension_), "");
   End-If;
   Return &sContentType_;
   
end-method;

/*
 * Get the file extension to map to MIME Table.
 */
method getFileExtension
   /+ &sAttachFileName_ as String +/
   /+ Returns String +/
   
   Local array of string &arrSplitFile_ = Split(&sAttachFileName_, ".");
   If &arrSplitFile_.Len > 1 Then
      %This.debug("File extension : " | &arrSplitFile_ [&arrSplitFile_.Len]);
      Return &arrSplitFile_ [&arrSplitFile_.Len];
   Else
      %This.debug("Invalid file extension");
      Return "";
   End-If;
   
end-method;

/*
 * Convert file to BASE64 encoded string.
 */
method binaryToBase64
   /+ &oReceiptFile_ as String, +/
   /+ &sFilePath_ as String +/
   /+ Returns String +/
   
   Local string &sFileAsBase64_, &sFileDir_;
   Local File &oFile_;
   &sFileAsBase64_ = "";
   
   If None(&sFilePath_) Then /* This is what we rely on for most use-cases */
      rem &sFileDir_ = &sPSServDir_ | %This.sPathSeparator_ | "files" | %This.sPathSeparator_ | &oReceiptFile_;
      &sFileDir_ = %This.ensureDirectoryHasTrailingSlash(%This.sFileUploadDir_) | &oReceiptFile_;
      %This.debug("binaryToBase64 FileDirAndFile : " | &sFileDir_);
   Else
      &sFileDir_ = %This.ensureDirectoryHasTrailingSlash(&sFilePath_) | &oReceiptFile_;
      %This.debug("ELSE binaryToBase64 FileDirAndFile : " | &sFileDir_);
   End-If;
   If FileExists(&sFileDir_, %FilePath_Absolute) Then
      &oFile_ = GetFile(&sFileDir_, "R", %FilePath_Absolute);
      If Not &oFile_.IsOpen Then
         &sFileAsBase64_ = "";
         %This.debug("File isn't open : " | &oFile_.Name);
         rem MessageBox(0, "", 0, 0, "File isn't open");
         throw CreateException(18130, 17212, "Unable to open file %1", &oFile_.Name);
         Exit (1);
      Else
         &sFileAsBase64_ = &oFile_.GetBase64StringFromBinary();
         &oFile_.Close();
         rem &oFile_.Delete();
      End-If;
   Else
      %This.logRequest("File " | &sFileDir_ | " does not exist", "");
      %This.debug("File " | &sFileDir_ | " does not exist");
   End-If;
   %This.sBASE64FileData_ = &sFileAsBase64_;
   
   Return &sFileAsBase64_;
   
end-method;

method logSvcResponse
   /+ &sPSPayloadBody_ as String +/
   /+ Returns Boolean +/
   
   Local string &sID_, &sMethodName_;
   Local boolean &bSQLStatus_;
   
   &sMethodName_ = "ServiceIntegration:logSvcResponse";
   Local time &startTime_ = %PerfTime;
   <* 
   REM Write output file;
   Local File &oOutputFile_ = GetTempFile(&sPSServDir_ | %This.sPathSeparator_ | "files" | %This.sPathSeparator_ | "SvcResponse_" | %Date | "_" | %PerfTime | ".out", "W", %FilePath_Absolute);
   &oOutputFile_.WriteString(&sSvcResponse_);
   rem %This.debug("");
   %This.debug("Log Svc Payload to File " | &oOutputFile_.Name | " and SQL Table");
   &oOutputFile_.Close();
   *>
   REM INSERT INTO Table as CLOB else JSON column;
   &bSQLStatus_ = False;
   Local SQL &sqlINSERT_ = CreateSQL("INSERT INTO %Table(PA_PS_2_XXX) (ACEEVALID, DATETIMEVAL1, FILENAME, APS_EXPORT_DIRFILE, ADDITIONAL_NOTE, ADDITIONAL_DATA, MIN_SIG_CAP_BASE64) VALUES (:1, %dateTimeIn(:2), :3, :4, %TextIn(:5), %TextIn(:6), %TextIn(:7))");
   Evaluate &sqlINSERT_.Status
   When = %SQLStatus_OK
      try
         rem &sID_ = GetJavaClass("java.util.UUID").randomUUID().toString();
         &bSQLStatus_ = &sqlINSERT_.Execute(&sBoundary_, %Datetime, %This.sSysFileName_, %This.sFileUploadDir_, &sPSPayloadBody_, &sSvcResponse_, %This.sBASE64FileData_);
         If &sqlINSERT_.RowsAffected = 0 Then
            %This.debug("No rows inserted.");
         Else
            %This.debug("INSERT SQL inserted : " | &sqlINSERT_.RowsAffected | " rows with UUID : " | &sBoundary_);
         End-If;
         &sqlINSERT_.Close();
         CommitWork();
      catch Exception &eSQL_
         rem %This.debug("");
         %This.debug("SQL Error : " | &eSQL_.ToString());
      end-try;
      Break;
   When = %SQLStatus_NotFound
      rem %This.debug("");
      %This.debug("Invalid SQL status for Transaction Record");
      Error ("Record Not Found");
      Break;
   When = %SQLStatus_Duplicate
      rem %This.debug("");
      %This.debug("Duplicate Record");
      Error ("Duplicate Record");
      Break;
   End-Evaluate;
   Local time &endTime_ = %PerfTime;
   %This.logPollSpanTime(&sMethodName_, &startTime_, &endTime_);
   
   Return &bSQLStatus_;
   
end-method;

/*
 * Sync Call to the Service Endpoint.
 * Return array element 1 is PS Payload.
 * Return array element 2 is Service Response.
 * 1.URL, 2.Auth, 3.Header, 4.Body, 5.Method
 */
method callService
   /+ &arrHdr#_ as Array of String, +/
   /+ &arrBody#_ as Array of String, +/
   /+ &sFileUpload_ as String +/
   /+ Returns Array of String +/
   
   rem Local PTDirectTransferObject &oPTDT_;
   Local string &sMethodName_, &sBody_, &sCheckFileExists_;
   Local array of string &arrBody#Resp_;
   Local integer &iBody_, &iMethod_, &iURL_, &iAuth_, &iHeader_;
   Local boolean &bSQLCheck_;
   
   &sMethodName_ = "ServiceIntegration:callService";
   Local time &startTime_ = %PerfTime;
   &arrBody#Resp_ = CreateArrayRept("", 0); /* Empty array of strings */
   
   If (%This.sSysFileName_ = "") Then
      %This.sSysFileName_ = &sFileUpload_;
      %This.debug("Filename " | %This.sSysFileName_ | " passed via callService");
      %This.transferAttachment();
   Else
      %This.debug("Filename " | %This.sSysFileName_ | " set by uploadAttachment");
   End-If;
   REM *** If the file does not exist, exit processing ***;
   &sCheckFileExists_ = %This.ensureDirectoryHasTrailingSlash(%This.sFileUploadDir_) | %This.sSysFileName_;
   If FileExists(&sCheckFileExists_, %FilePath_Absolute) Then
      %This.debug(&sMethodName_ | " File : " | &sCheckFileExists_ | " exists. Proceed with building header and body.");
      &oPTDirTrf_ = CreateDirecttransferObject(); /* Perform cURL transfer */
      try
         &iURL_ = &oPTDirTrf_.SetURL(&sSvcURL_);
         rem %This.buildAuth();
         /* 
         &iHeader_ = &oPTDirTrf_.SetHeader(&sExpAppID_);
         &iHeader_ = &oPTDirTrf_.SetHeader(&sTenantID_);
         &sBoundary_ = GetJavaClass("java.util.UUID").randomUUID().toString();
         %This.debug("");
         %This.debug("Unique Boundary : " | &sBoundary_);
         &iHeader_ = &oPTDirTrf_.SetHeader(&sMultipartFormData_ | &sBoundary_);
         */
         %This.buildHeader(&arrHdr#_); /* Apply headers and generate GUID */
         &sBody_ = %This.buildBody("", &sBoundary_, &arrBody#_);
         rem &iHeader_ = &oPTDirTrf_.SetHeader(&sContentLength_ | String(Len(&sBody_)));
         If All(&sBody_) Then
            %This.bCallSvc_ = True; /* Set to True for client app to call JSON parsing */
            &iBody_ = &oPTDirTrf_.SetBody(&sBody_);
            &iMethod_ = &oPTDirTrf_.SetMethod(&sMethod_); /* Calss currently defaults it to POST */
            rem %This.debug("");
            %This.logRequest(&sMethodName_ | " Ready to Call (" | &sMethod_ | ") Service Endpoint : " | &sSvcURL_, "");
            %This.debug("Ready to Call (" | &sMethod_ | ") Service Endpoint : " | &sSvcURL_);
            &sSvcResponse_ = &oPTDirTrf_.SyncTransfer(); /* Submit a synchronous cURL transfer request; Call blocking */
            %This.debug("++++----++++");
            %This.debug(&sSvcResponse_);
            %This.debug("++++----++++");
            %This.sSvcRespPayload_ = &sSvcResponse_; /* Assign to property; will be used to pass for parsing */
            &arrBody#Resp_ [1] = &sBody_;
            &arrBody#Resp_ [2] = &sSvcResponse_;
            &bSQLCheck_ = %This.logSvcResponse(&sBody_);
         Else
            %This.bCallSvc_ = False;
            %This.sSvcRespPayload_ = "";
            %This.sSysFileName_ = "";
            %This.sGUID_ = "";
            %This.logRequest(&sMethodName_ | " Invalid multipart/form-data", "");
            %This.debug(&sMethodName_ | " Invalid multipart/form-data");
            Return &arrBody#Resp_;
         End-If;
      catch Exception &errSvc_
         rem %This.logRequest(&sMethodName_ | " Exception Response: ", &sSvcResponse_.GetContentString());
         %This.logRequest(&sMethodName_ | " ERROR: ", &errSvc_.ToString());
         %This.debug("");
         %This.debug("ERROR: " | &errSvc_.ToString());
         throw &errSvc_;
      end-try;
      &oPTDirTrf_.Reset(); /* Reset the Direct Transfer object */
   Else
      %This.bCallSvc_ = False;
      %This.sSvcRespPayload_ = "";
      %This.sSysFileName_ = "";
      %This.sGUID_ = "";
      %This.logRequest(&sMethodName_ | " File " | &sCheckFileExists_ | " does not exist. Call to Svc skipped", "");
      %This.debug(&sMethodName_ | " File " | &sCheckFileExists_ | " does not exist. call to Svc skipped");
   End-If;
   Local time &endTime_ = %PerfTime;
   %This.logPollSpanTime(&sMethodName_, &startTime_, &endTime_);
   rem &oPTDirTrf_.Reset();
   rem Return &sSvcResponse_;
   Return &arrBody#Resp_;
   
end-method;

/* 
 * Create JSONParser Object 
 */
method getJSONParser
   /+ &content_ as String +/
   /+ Returns JsonObject +/
   
   Local JsonParser &parser_ = CreateJsonParser();
   Local JsonObject &jObj_;
   
   If None(&content_) Then
      Return Null;
   Else
      try
         Local boolean &status_ = &parser_.Parse(&content_);
         If &status_ Then
            &jObj_ = &parser_.GetRootObject();
            Return &jObj_;
         Else
            Return Null; /* Unable to parse the response payload */
         End-If;
         rem Return &jObj_;
      catch Exception &errParse_
         rem MessageBox(0, "", 0, 0, "Error while parsing Svc Payload : " | &errParse_.ToString());
         %This.logRequest(" Error while parsing Svc Payload : " | &errParse_.ToString(), "");
         %This.debug("");
         %This.debug("Error while parsing Svc Payload : " | &errParse_.ToString());
         Error (MsgGetText(18130, 15001, "Unhandled exception occurred in %1.", "getJsonParser"));
      end-try;
   End-If;
   
end-method;

/*
 * Evaluate each JSON Node.
 * JSONPath from config is used in this method to push "key-value" pairs into an array.
 */
method evalNodeType
   /+ &oEvalJS_ as JsonObject, +/
   /+ &sNodeName_ as String, +/
   /+ &sPath_ as String, +/
   /+ &nCount_ as Number +/
   /+ Returns String +/
   
   Local JsonNode &oJSNode_, &oParentJSNode_;
   Local string &sNodeType_, &sSomeStr_, &sMethodName_, &sGetStr_, &sJsonPath_;
   Local JsonObject &oJSLvl1_, &oJSArrLvl1_;
   Local JsonArray &oJSArray1_;
   Local number &nJSLvl1ChildCount_, &nGetNumber_;
   Local integer &iNodeValue_, &iGetInt_, &nArrLen_, &nArrCount_;
   Local float &fGetFloat_;
   Local boolean &bGetBool_;
   
   &oJSNode_ = &oEvalJS_.GetJsonNode("" | &sNodeName_ | "");
   &sJsonPath_ = &sPath_;
   &n2DArrCnt_ = 0;
   Evaluate &oJSNode_.NodeType
   When = 0
      %This.debug("");
      %This.debug(&sNodeName_ | " NodeType : " | "NULL");
      &sNodeType_ = "JSON_NODE_NULL";
      Break;
   When = 1
      rem %This.debug("");
      &sNodeType_ = "JSON_NODE_OBJECT";
      rem &oParentJSNode_ = &oJSNode_.GetParentNode();
      &oJSLvl1_ = &oEvalJS_.GetJsonObject("" | &sNodeName_ | "");
      %This.debug(&sNodeName_ | " NodeType : " | "OBJECT" | " ChildCount : " | &oJSLvl1_.ChildCount);
      &sJsonPath_ = &sPath_ | "." | &sNodeName_;
      rem %This.ensureJSONPathHasLeadingDollar(&sJsonPath_);
      Evaluate &sJsonPath_
      When = "$.predictionResult.categories.Merchant.fields.MerchantName"
      When = "$.predictionResult.categories.ExpensesCategory.fields.ExpenseCategory"
      When = "$.predictionResult.categories.ExpenseData.fields.DATE_VALUE"
      When = "$.predictionResult.categories.ExpenseData.fields.AMOUNT_VALUE"
      When = "$.predictionResult.categories.Currency.fields.CurrencyName"
      When = "$.predictionResult.categories.Currency.fields.CurrencyNameCandidates"
      When = "$.predictionResult.categories.Currency.fields.CurrencyCode"
      When = "$.predictionResult.categories.Currency.fields.CurrencyCodeCandidates"
      When = "$.predictionResult.categories.Location.fields.Country"
      When = "$.predictionResult.categories.Location.fields.CountryNameCandidates"
      When = "$.predictionResult.categories.Location.fields.CountryCode"
      When = "$.predictionResult.categories.Location.fields.CountryCodeCandidates"
      When = "$.predictionResult.categories.ExpenseData.fields.AUTH_CODE_VALUE"
         &arrJsonPath_.Push(CreateArray(&sNodeName_, &sJsonPath_));
         Break;
      When-Other
         Break;
      End-Evaluate;
      
      For &nJSLvl1ChildCount_ = 1 To &oJSLvl1_.ChildCount
         rem &sPath_ = &sPath_ | "." | &oJSLvl1_.GetPropertyNameAt(&nJSLvl1ChildCount_);
         <* %This.logRequest(" (Key : Value) (" | &oJSLvl1_.GetPropertyNameAt(&nJSLvl1ChildCount_) | " : " | &oJSLvl1_.GetProperty(&oJSLvl1_.GetPropertyNameAt(&nJSLvl1ChildCount_)) | ")", " <-- Path --> " | &sPath_ | "." | &sNodeName_); *>
         rem %This.logRequest(" ", " (Key : Value) (" | &oJSLvl1_.GetPropertyNameAt(&nJSLvl1ChildCount_) | " : " | &oJSLvl1_.GetProperty(&oJSLvl1_.GetPropertyNameAt(&nJSLvl1ChildCount_)) | ")");
         &sSomeStr_ = %This.evalNodeType(&oJSLvl1_, &oJSLvl1_.GetPropertyNameAt(&nJSLvl1ChildCount_), &sPath_ | "." | &sNodeName_, &oJSLvl1_.ChildCount);
      End-For;
      Break;
   When = 2
      %This.debug("");
      %This.debug(&sNodeName_ | " NodeType : " | "ARRAY");
      &sJsonPath_ = &sPath_ | "." | &sNodeName_;
      &sNodeType_ = "JSON_NODE_ARRAY";
      &oJSArray1_ = &oEvalJS_.GetJsonArray("" | &sNodeName_ | "");
      If &oJSArray1_.Size > 0 Then
         &nArrLen_ = &oJSArray1_.Length();
         For &nArrCount_ = 1 To &nArrLen_
            &oJSArrLvl1_ = &oJSArray1_.GetJsonObject(&nArrCount_);
            &sSomeStr_ = %This.evalNodeType(&oJSArrLvl1_, &oJSArrLvl1_.GetPropertyNameAt(&nArrCount_), &sPath_ | "." | &sNodeName_, &oJSArrLvl1_.ChildCount);
         End-For;
      End-If;
      Break;
   When = 3
      rem %This.debug("");
      &arrKeyValue_.Push(CreateArrayAny(&sNodeName_, &oJSNode_.GetJsonValue().GetValue(), &sJsonPath_));
      /* 
      &arrKeyValue_.Push(&sNodeName_);
      &arrKeyValue_ [1].Push(&oJSNode_.GetJsonValue().GetValue());
      &n2DArrCnt_ = &n2DArrCnt_ + 1;
      */
      rem %This.debug(&sNodeName_ | " NodeType : " | "ValueType : " | &oJSNode_.ValueType | " : Value : " | &oJSNode_.GetJsonValue().GetValue());
      <* 
      &iNodeValue_ = &oJSNode_.GetValueType();
      Evaluate &iNodeValue_
      When = 0
         Error ("JSON_VALUE_INVALID");
         Break;
      When = 1
         &iGetInt_ = &oJSNode_.GetInteger();
         %This.debug(&sNodeName_ | " NodeType  " | " Int Value : " | &iGetInt_);
         Break;
      When = 2
         &fGetFloat_ = &oJSNode_.GetFloat();
         %This.debug(&sNodeName_ | " NodeType  " | " Float Value : " | &fGetFloat_);
         Break;
      When = 3
         rem DOUBLE;
         %This.debug(&sNodeName_ | " NodeType  " | " Double Value : " | &oJSNode_.GetJsonValue().GetValue());
         Break;
      When = 4
         &nGetNumber_ = &oJSNode_.GetNumber();
         %This.debug(&sNodeName_ | " NodeType  " | " Number Value : " | &nGetNumber_);
         Break;
      When = 5
         &bGetBool_ = &oJSNode_.GetBoolean();
         %This.debug(&sNodeName_ | " NodeType  " | " Bool Value : " | &bGetBool_);
         Break;
      When = 6
         &sGetStr_ = &oJSNode_.GetString();
         %This.debug(&sNodeName_ | " NodeType  " | " String Value : " | &sGetStr_);
         Break;
      When = 7
         rem NULL;
         Break;
      When = 8
         rem DATE;
         %This.debug(&sNodeName_ | " NodeType  " | " DATE Value : " | &oJSNode_.GetJsonValue().GetValue());
         Break;
      When = 9
         rem TIME;
         %This.debug(&sNodeName_ | " NodeType  " | " TIME Value : " | &oJSNode_.GetJsonValue().GetValue());
         Break;
      When = 10
         rem DATETIME;
         %This.debug(&sNodeName_ | " NodeType  " | " DATETIME Value : " | &oJSNode_.GetJsonValue().GetValue());
         Break;
      When-Other
         Break;
      End-Evaluate;
      *>
      &sNodeType_ = "JSON_NODE_VALUE";
      Break;
   When-Other
      rem Invalid NodeType;
      &sNodeType_ = "";
      Error ("Invalid JsonNode");
      Break;
   End-Evaluate;
   
   Return &sNodeType_;
end-method;

method parseSvcResponse
   /+ &sJSONResp_ as String +/
   
   Local JsonObject &oJSONObj_;
   Local number &nPredResultChildCount_, &nLvl1ChildCount_, &nLvl2ChildCount_;
   Local number &nCatChildCount_, &nUnderCatgChildCount_, &nFieldsChildCount_;
   Local string &sMethodName_;
   Local integer &i_, &j_, &m_doccount_;
   
   &sMethodName_ = "ServiceIntegration:parseSvcResponse";
   Local time &startTime_ = %PerfTime;
   
   rem &oJSONObj_ = %This.getJSONParser(&sSvcResponse_);
   &oJSONObj_ = %This.getJSONParser(&sJSONResp_);
   If (&oJSONObj_ <> Null) Then
      Local string &sRootNode_ = &oJSONObj_.GetPropertyNameAt(1); /* Get Root Node */
      rem %This.debug(&sRootNode_ | " ChildCount : " | &oJSONObj_.ChildCount);
      If (&oJSONObj_.IsJsonArray("")) Or
            &oJSONObj_.IsJsonArray(&sRootNode_) Then
         %This.debug("");
         %This.debug("Payload starts with an Array : " | &sRootNode_);
         Local JsonArray &oJSArray_ = &oJSONObj_.GetJsonArray(&sRootNode_);
         If &oJSArray_.Size > 0 Then
            &m_doccount_ = &oJSArray_.Length();
            For &i_ = 1 To &m_doccount_
               Local JsonObject &oJSArrObj_ = &oJSArray_.GetJsonObject(&i_);
               &sEvalNodeType_ = %This.evalNodeType(&oJSArrObj_, &oJSArrObj_.GetPropertyNameAt(&i_), &sRoot_, &i_); /* Recursive Call */
            End-For;
         End-If; /* Read Array */
      Else
         If &oJSONObj_.IsJsonObject(&sRootNode_) Then
            %This.debug("");
            %This.debug("Payload starts with an Object : " | &sRootNode_);
            rem %This.debug("&sRootNode_ " | &sRootNode_);
            If &oJSONObj_.IsExist(&sRootNode_) Then
               &n2DArrCnt_ = 0;
               &sEvalNodeType_ = %This.evalNodeType(&oJSONObj_, &sRootNode_, &sRoot_, 0); /* Recursive Call */
               rem %This.logJSONToDB();
            Else /* predictionResult */
               %This.logRequest(&sMethodName_ | " *** Stop processing; Root Node is NOT : " | &sRootNode_ | " *** ", "");
               %This.debug(" *** Stop processing; Root Node is NOT : " | &sRootNode_ | " *** ");
            End-If; /* predictionResult */
         End-If; /* IsJsonObject */
      End-If; /* IsJsonArray */
      
      rem %This.logJSONToDB(); /* Store ALL Key-Value Pair(s) */
      If &arrJsonPath_.Len > 1 Then
         Local integer &iArrCnt_;
         For &iArrCnt_ = 1 To &arrJsonPath_.Len
            %This.getJSONPath(&oJSONObj_, &arrJsonPath_ [&iArrCnt_][1], &arrJsonPath_ [&iArrCnt_][2]); /* JsonPath */
         End-For;
      End-If;
      %This.logKVP(); /* Store Core Key-Value Pairs */
      %This.cleanArrays(&arrJsonPath_);
   Else
      %This.logRequest(&sMethodName_ | " *** JSON could not be parsed *** ", "");
      %This.debug("");
      %This.debug("JSON could not be parsed");
      rem MessageBox(0, "", 0, 0, "JSON could not be parsed");
   End-If;
   
   Local time &endTime_ = %PerfTime;
   %This.logPollSpanTime(&sMethodName_, &startTime_, &endTime_);
   %This.sSysFileName_ = "";
   
end-method;

method getJSONPath
   /+ &oEvalJS_ as JsonObject, +/
   /+ &sSelNodeName_ as String, +/
   /+ &sNodePath_ as String +/
   
   Local array of string &arrSplitJSPath_;
   Local string &sValue_, &sJSOutput_, &sName_;
   Local integer &iStart_, &iLoop_;
   Local number &nCount_;
   Local array of any &arrAny_ = CreateArrayAny();
   Local JsonObject &oJSPath_;
   
   rem &arrSplitJSPath_ = Split("$.predictionResult.categories.ExpenseData.fields.DATE_VALUE_DD_MM_YY", ".");
   &arrSplitJSPath_ = Split(&sNodePath_, ".");
   
   &oJSPath_ = &oEvalJS_;
   If &arrSplitJSPath_.Len > 1 Then
      For &iStart_ = 2 To &arrSplitJSPath_.Len
         &oJSPath_ = &oJSPath_.GetJsonObject(&arrSplitJSPath_ [&iStart_]);
      End-For;
   Else
      %This.debug("getJSONPath incorrect array length : " | &arrSplitJSPath_.Len);
   End-If;
   rem Local JsonObject &oJSPath_ = &oEvalJS_.GetJsonObject("" | &arrAny_ [1] | "").GetJsonObject("" | &arrAny_ [2] | "").GetJsonObject("" | &arrAny_ [3] | "").GetJsonObject("" | &arrAny_ [4] | "").GetJsonObject("" | &arrAny_ [5] | "");
   If (&oJSPath_ <> Null) Then
      Local JsonNode &oJSNameNode_ = &oJSPath_.GetJsonNode("name");
      Local JsonNode &oJSValueNode_ = &oJSPath_.GetJsonNode("value");
      If &oJSValueNode_ <> Null Then
         &sName_ = String(&oJSNameNode_.GetJsonValue().GetValue());
         &sValue_ = String(&oJSValueNode_.GetJsonValue().GetValue());
         rem %This.debug("");
         rem %This.debug(&sNodePath_ | " --> " | " Name : " | &sName_ | " : Value : " | &sValue_);
         %This.logRequest(&sNodePath_ | " --> ", " Name : " | &sName_ | " : Value : " | &sValue_);
         &arrReturnValues_.Push(CreateArray(&sName_, &sValue_));
      Else
         rem %This.debug("");
         %This.debug("Invalid JSNode");
      End-If;
   Else
      rem %This.debug("");
      %This.debug("Recursive JsonObject is NULL");
   End-If;
   rem Local string &sPropName_ = &oJSPath_.GetPropertyNameAt(2);
   rem %This.debug("&sPropName_ " | &sPropName_);
   rem &oJSOn_ = &oJSPath_.GetJsonObject(&sPropName_);
   
end-method;

method logJSONToDB
   
   Local integer &nArrAnyIndex_, &nJ_;
   Local SQL &sqlInsert_;
   Local Record &recSvcChild_;
   Local string &sMethodName_;
   
   &sMethodName_ = "ServiceIntegration:logJSONToDB";
   Local time &startTime_ = %PerfTime;
   
   &sqlInsert_ = CreateSQL("%INSERT(:1)");
   &recSvcChild_ = CreateRecord(Record.PA_PS2XXX_CHLD);
   &sqlInsert_.BulkMode = True;
   try
      If (&arrKeyValue_.Len > 0) Then
         &nArrAnyIndex_ = 0;
         While &arrKeyValue_.Next(&nArrAnyIndex_);
            &nJ_ = 1;
            &recSvcChild_.ACEEVALID.Value = &sBoundary_;
            &recSvcChild_.SEQNBR.Value = &nArrAnyIndex_;
            &recSvcChild_.PTWC_KEYNAME.Value = &arrKeyValue_ [&nArrAnyIndex_][1];
            &nJ_ = &nJ_ + 1;
            &recSvcChild_.PTWC_KEYVALUE.Value = &arrKeyValue_ [&nArrAnyIndex_][2];
            &recSvcChild_.PTPPB_XPATH.Value = &arrKeyValue_ [&nArrAnyIndex_][3];
            rem %This.debug(&recSvcChild_.PTWC_KEYNAME.Value | " : " | &recSvcChild_.PTWC_KEYVALUE.Value);
            &sqlInsert_.Execute(&recSvcChild_);
            rem &nArrAnyIndex_ = &nArrAnyIndex_ + 1;
         End-While;
      Else
         rem %This.debug("");
         %This.debug("Array is EMPTY");
      End-If;
   catch Exception &errLogToDB_
      %This.logRequest(&sMethodName_ | " Error logged while saving JSON : " | &errLogToDB_.ToString(), "");
      rem %This.debug("");
      %This.debug("Error logged while saving JSON : " | &errLogToDB_.ToString());
   end-try;
   CommitWork();
   &sqlInsert_.Close();
   
   Local time &endTime_ = %PerfTime;
   %This.logPollSpanTime(&sMethodName_, &startTime_, &endTime_);
   
end-method;

/*
 * Store value-value pair in a table
 * Table is keyed by UUID
 */
method logKVP
   
   Local integer &nArrKVPIndex_;
   Local SQL &sqlInsertKVP_;
   Local Record &recSvcKVP_;
   Local string &sMethodName_;
   
   &sMethodName_ = "ServiceIntegration:logKVP";
   Local time &startTime_ = %PerfTime;
   
   &sqlInsertKVP_ = CreateSQL("%INSERT(:1)");
   &recSvcKVP_ = CreateRecord(Record.PA_PS2XXX_KVP);
   &sqlInsertKVP_.BulkMode = True;
   try
      If (&arrReturnValues_.Len > 0) Then
         &nArrKVPIndex_ = 0;
         While &arrReturnValues_.Next(&nArrKVPIndex_);
            &recSvcKVP_.ACEEVALID.Value = &sBoundary_;
            &recSvcKVP_.SEQNBR.Value = &nArrKVPIndex_;
            &recSvcKVP_.PTWC_KEYNAME.Value = &arrReturnValues_ [&nArrKVPIndex_][1];
            &recSvcKVP_.PTWC_KEYVALUE.Value = &arrReturnValues_ [&nArrKVPIndex_][2];
            rem &recSvcKVP_.PTPPB_XPATH.Value = &arrReturnValues_ [&nArrKVPIndex_][3];
            rem %This.debug(&recSvcKVP_.PTWC_KEYNAME.Value | " : " | &recSvcKVP_.PTWC_KEYVALUE.Value);
            &sqlInsertKVP_.Execute(&recSvcKVP_);
            rem &nArrKVPIndex_ = &nArrKVPIndex_ + 1;
         End-While;
      Else
         %This.logRequest(&sMethodName_ | " KVP Array is EMPTY", "");
         rem %This.debug("");
         %This.debug("KVP Array is EMPTY");
      End-If;
   catch Exception &errLogKVP_
      %This.logRequest(&sMethodName_ | " Error logged while saving KVP : " | &errLogKVP_.ToString(), "");
      rem %This.debug("");
      %This.debug("Error logged while saving KVP : " | &errLogKVP_.ToString());
   end-try;
   CommitWork();
   &sqlInsertKVP_.Close();
   
   Local time &endTime_ = %PerfTime;
   %This.logPollSpanTime(&sMethodName_, &startTime_, &endTime_);
   
end-method;

method getPathSeparator
   
   Local string &sPathVar_, &sSlash_;
   Local integer &iTempPos_;
   &sPathVar_ = &sPSServDir_;
   /* Determine the file path separator character. First check for backslash then forwardslash. */
   &iTempPos_ = Find("\", &sPathVar_);
   If &iTempPos_ = 0 Then
      &iTempPos_ = Find("/", &sPathVar_);
      &sSlash_ = "/";
      %This.debug("");
      %This.debug("UNIX Forwardslash : " | &sSlash_);
   Else
      &sSlash_ = "\";
      %This.debug("");
      %This.debug("Windows Backslash : " | &sSlash_);
   End-If;
   
   %This.sPathSeparator_ = &sSlash_;
   
end-method;

method logRequest
   /+ &function as String, +/
   /+ &request as String +/
   
   Local string &startMarking = "***START***";
   Local string &endMarking = "***END***";
   Local string &newStr = Char(13);
   Local integer &length = Len(&request);
   If &length < 4096 Then
      WriteToLog(%ApplicationLogFence_Error, &function | &request);
   Else
      /* 4096 - ( 256 * 2 ) */
      Local integer &segmentSize = 3586;
      Local integer &segmentCout = &length / &segmentSize;
      Local integer &segmentMod = Mod(&length, &segmentSize);
      Local integer &index = 0;
      Local string &segmentStr = "";
      Local integer &startPos = 1;
      For &index = 1 To &segmentCout Step 1
         &segmentStr = Substring(&request, &startPos, &segmentSize);
         WriteToLog(%ApplicationLogFence_Error, &function | "Part " | &index | " :" | &newStr | &startMarking | &segmentStr | &endMarking);
         &startPos = &startPos + &segmentSize;
      End-For;
      If &segmentMod <> 0 Then
         &index = &index + 1;
         &segmentStr = Substring(&request, &startPos, &segmentMod);
         WriteToLog(%ApplicationLogFence_Error, &function | "Part " | &index | " :" | &newStr | &startMarking | &segmentStr | &endMarking);
      End-If;
   End-If;
end-method;

method logPollSpanTime
   /+ &sMethodName_ as String, +/
   /+ &startTime_ as Time, +/
   /+ &endTime_ as Time +/
   
   %This.logRequest("Method : " | &sMethodName_ | " Poll Time (s) ", NumberToString("%6.3", Value(&endTime_ - &startTime_)));
end-method;

method debug
   /+ &sText as String +/
   
   If &bDebug_ Then
      WriteToLog(%ApplicationLogFence_Error, &sText);
   End-If;
   
end-method;

method getCombineRegExp
   /+ Returns String +/
   rem Return "^\+[a-zA-Z]{1}[a-zA-Z0-9]{3}[a-zA-Z0-9]{1,18}\d{1}";
   rem Return "\?\u0007\x00\x1f\x7f\x9f";
   Return "[\?\u0007\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]";
end-method;

method regexPattern
   /+ &sInput_ as String +/
   /+ Returns Boolean +/
   
   Local JavaObject &oPatternClass_ = GetJavaClass("java.util.regex.Pattern");
   <* Local JavaObject &oPattern_ = &oPatternClass_.compile("[@$%^&\\/|=+*#~`\(\)<>\[\]{}:;?\']"); *>
   Local string &sRegx_ = %This.getCombineRegExp();
   Local JavaObject &oPattern_ = &oPatternClass_.compile(&sRegx_);
   Local JavaObject &oJString_ = CreateJavaObject("java.lang.String", &sInput_);
   rem Local JavaObject &oMatches_ = &oPattern_.matcher(&oJString_);
   Local JavaObject &oMatches_ = &oPattern_.matcher(&oJString_.subSequence(0, &oJString_.length()));
   Local JavaObject &int_ = GetJavaClass("java.lang.Integer");
   Local string &sOutput_ = &sInput_;
   Local string &sReplacement_, &sMatch_;
   Local number &nOffset_ = 1;
   
   rem If (&oMatches_.matches()) Then;
   While (&oMatches_.find())
      &sMatch_ = &oMatches_.group();
      &sReplacement_ = "\u" | Right("0000" | &int_.toHexString(Code(&sMatch_)), 4);
      &sOutput_ = Replace(&sOutput_, &oMatches_.start() + &nOffset_, (&oMatches_.end() - &oMatches_.start()), &sReplacement_);
      &nOffset_ = &nOffset_ + Len(&sReplacement_) - (&oMatches_.end() - &oMatches_.start());
   End-While;
   %This.debug("");
   %This.debug("After pattern matching : " | &sOutput_);
   If &oMatches_.find() Then
      Return False;
   Else
      Return True;
   End-If;
end-method;

/* 
 * This method will delete a file 
*/
method FileDelete
   /+ &strFilePath_ as String +/
   
   Local File &oFileDel_;
   
   &oFileDel_ = GetTempFile(&strFilePath_, "W", "A", %FilePath_Absolute);
   If &oFileDel_.IsOpen Then
      &oFileDel_.Delete();
   Else
      %This.debug("Unable to delete File : " | &oFileDel_.Name | " as it is not open.");
      %This.logRequest("Unable to delete File : " | &oFileDel_.Name | " as it is not open.", "");
   End-If;
   
end-method;

method addForwardSlash
   /+ &sDirStr_ as String +/
   /+ Returns String +/
   
   If (All(&sDirStr_) And
         Right(&sDirStr_, 1) <> "/") Then
      &sDirStr_ = &sDirStr_ | "/";
   End-If;
   Return (&sDirStr_);
end-method;

method addBackSlash
   /+ &sDirStr_ as String +/
   /+ Returns String +/
   
   If (All(&sDirStr_) And
         Right(&sDirStr_, 1) <> "\") Then
      &sDirStr_ = &sDirStr_ | "\";
   End-If;
   Return (&sDirStr_);
end-method;

method findAddSlash
   /+ &sDirStr_ as String +/
   /+ Returns String +/
   
   Local number &slashpos;
   If All(&sDirStr_) Then
      &slashpos = Find("\\", &sDirStr_);
      If &slashpos <> 0 Then
         &sDirStr_ = %This.addBackSlash(&sDirStr_);
      Else
         &slashpos = Find("/", &sDirStr_);
         If &slashpos <> 0 Then
            &sDirStr_ = %This.addForwardSlash(&sDirStr_);
         Else
            &slashpos = Find("\", &sDirStr_);
            If &slashpos <> 0 Then
               &sDirStr_ = %This.addBackSlash(&sDirStr_);
            End-If;
         End-If;
      End-If;
   End-If;
   
   Return (&sDirStr_);
   
end-method;

/*
 * The purpose of this method is to ensure that the given directory value
 * always has a trailing slash. The value of the slash is system dependent.
*/
method ensureDirectoryHasTrailingSlash
   /+ &sDirStr_ as String +/
   /+ Returns String +/
   
   If "/" = Left(&sDirStr_, 1) Then
      rem UNIX;
      If "/" = Right(&sDirStr_, 1) Then
         Return &sDirStr_;
      Else
         Return (&sDirStr_ | "/");
      End-If;
   Else
      rem Windows;
      If "\" = Right(&sDirStr_, 1) Then
         Return &sDirStr_;
      Else
         Return (&sDirStr_ | "\");
      End-If;
   End-If;
   
end-method;

method cleanArrays
   /+ &arrClean_ as Array2 of String +/
   
   Local integer &iArrLen_;
   For &iArrLen_ = 1 To &arrClean_.Len
      &arrClean_.Pop();
   End-For;
   
end-method;

/*
 * Regenerate file if required
 * BASE64
 */
method regenerateFile
   /+ &sUserFileName_ as String +/
   
   Local File &oTempFile_;
   Local string &sFileData_;
   Local datetime &dtLogDTTM_;
   
   SQLExec("SELECT MAX(A.DATETIMEVAL1) FROM %TABLE(PA_PS_2_XXX) A WHERE 1 = 1 AND A.FILENAME = :1", &sUserFileName_, &dtLogDTTM_);
   SQLExec("SELECT A.MIN_SIG_CAP_BASE64 FROM %TABLE(PA_PS_2_XXX) A WHERE 1 = 1 AND A.DATETIMEVAL1 = %DateTimeOut(:1)", &dtLogDTTM_, &sFileData_);
   
   &oTempFile_ = GetTempFile(&sUserFileName_, "W", %FilePath_Absolute);
   If &oTempFile_.IsOpen Then
      &oTempFile_.WriteBase64StringToBinary(&sFileData_);
      &oTempFile_.Close();
   End-If;
   
end-method;

method ensureJSONPathHasLeadingDollar
   /+ &sJSONPathVal_ as String +/
   /+ Returns String +/
   
   Local string &sJSONUpdVal_;
   If "$." = Left(&sJSONPathVal_, 2) Then
      rem JSONPath correctly configured;
   Else
      rem missing Dollar and Dot;
      &sJSONPathVal_ = "$." | &sJSONPathVal_;
   End-If;
   
   Return &sJSONUpdVal_;
   
end-method;
