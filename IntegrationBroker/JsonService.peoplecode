import AM_IOT:Constants;

class JsonService
   method JsonService();
   /* Ping Test */
   rem method Ping(&sIoTInstanceName_ As string) Returns string;
   method Ping() Returns string;
   /* Retrieve IoT URIs */
   method fetchEndpoint(&sTask_ As string) Returns string;
   method cleanURI(&sInputURI_ As string) Returns string;
   /* JSON Parser */
   method objJsonParser(&content As string) Returns JsonObject;
   method hmacAuthenticationHeader(&url As string, &admnuser As string, &admnpass As string, &proxyuser As string, &proxypass As string, &serverurl As string) Returns string;
   method Base64AuthenticationHeader() Returns string;
   /* Replace <orgId> */
   method SubstituteURI(&sInputURI_ As string, &sIoTOrgID_ As string) Returns string;
   /* Send request to IoT */
   rem method sendRequest(&sIoTInstanceName_ As string, &sUrl_ As string, &sAction_ As string, &sRequest_ As string, &bPatch_ As boolean) Returns string;
   method sendRequest(&sUrl_ As string, &sAction_ As string, &sRequest_ As string, &bPatch_ As boolean) Returns string;
   /* Logging and debugging methods */
   method LogRequest(&function As string, &request As string);
   method logPollSpanTime(&sMethodName_ As string, &startTime_ As time, &endTime_ As time);
   method debug(&sText As string);
   
protected
   method printConsole(&promptMessage As string);
   method PSCipher();
   method encodePassword(&password As string) Returns string;
   method decodePassword(&password As string) Returns string;
   
private
   instance object &oPSCipher_;
   instance object &oString_;
   instance object &oHeader_;
   instance object &oEncoder_;
   Constant &bDebug = False;
   instance AM_IOT:Constants &oConstantService_;
   
end-class;

method JsonService
   
   &oConstantService_ = create AM_IOT:Constants();
end-method;

/* 
 * The status of Service Instance depends on the status of the messageStore and the cache. 
 * If both are Up, the status is Up; otherwise it is Down 
 */
method Ping
   /+ Returns String +/
   
   Local string &sRet_, &sPingIoTURI_, &sResponse_, &sMethodName_;
   Local JsonObject &oJsonObj_;
   Local number &nIoTRespTime_;
   &sRet_ = "";
   &sPingIoTURI_ = "";
   &sResponse_ = "";
   &sMethodName_ = "JsonService:Ping";
   
   rem &sPingIoTURI_ = %This.fetchEndpoint(&sIoTInstanceName_, "PING_TEST"); /* Monitoring - Retrieve Availability Status */
   &sPingIoTURI_ = %This.fetchEndpoint("PING_TEST"); /* Monitoring - Retrieve Availability Status */
   If &sPingIoTURI_ <> "" Then
      rem &sResponse_ = %This.sendRequest(&sIoTInstanceName_, &sPingIoTURI_, "GET", "", False); /* Send the request to IoT */
      &sResponse_ = %This.sendRequest(&sPingIoTURI_, "GET", "", False); /* Send the request to IoT */
      &oJsonObj_ = %This.objJsonParser(&sResponse_);
      If &oJsonObj_.IsExist("status") Then
         If &oJsonObj_.GetProperty("status") = "Up" Then
            &sRet_ = &oJsonObj_.GetProperty("status");
            &nIoTRespTime_ = &oJsonObj_.GetProperty("responseTime");
            %This.LogRequest(&sMethodName_ | " IoT Response Time (ms) : ", NumberToString("%6.3", Value(&nIoTRespTime_)));
         Else
            &sRet_ = ""; /* It is "Down" */
         End-If;
      Else
         &sRet_ = ""; /* unable to verify status */
      End-If;
   Else
      rem cannot ping IoT;
      &sRet_ = "";
      %This.LogRequest(&sMethodName_ | " Availability status for the Oracle IoT Clouse Service Instance UNKNOWN ! ", "");
   End-If;
   If &sRet_ = "" Then
      throw CreateException(0, 0, "Availability status for the Oracle IoT Clouse Service Instance UNKNOWN");
   End-If;
   
   Return &sRet_;
end-method;

/* 
 * Always fetch endpoints of the DEFAULT IoT instance 
 */
method fetchEndpoint
   /+ &sTask_ as String +/
   /+ Returns String +/
   
   Local string &sServerHost_, &sTaskURI_, &sPrivateTaskURI_, &sEndpointURL_, &sMethodName_;
   Local number &nServerPort_;
   &sMethodName_ = "JsonService:fetchEndpoint";
   Local SQL &sqlIoTDefInst_ = CreateSQL("%SelectAll(:1) WHERE AM_IOT_DFLT_INST = 'Y'", Record.PSOPRDEFN);
   Local Record &recIoTConfig_ = CreateRecord(Record.PSOPRDEFN);
   
   While &sqlIoTDefInst_.Fetch(&recIoTConfig_)
      &sServerHost_ = &recIoTConfig_.AM_IOT_HOST_NAME.Value;
      &nServerPort_ = &recIoTConfig_.AM_IOT_PORT.Value;
      &sTaskURI_ = &recIoTConfig_.AM_IOT_TASK_URI.Value;
      &sPrivateTaskURI_ = &recIoTConfig_.AM_IOT_PVT_TASK_URI.Value;
   End-While;
   rem SQLExec("SELECT SERVER_HOST, SERVER_PORT, TASK_URI, PVT_TASK_URI FROM PS_SOMETHING WHERE AM_IOT_INST_ID = :1 AND AM_IOT_TASK = :2", &sIoTInstanceName_, &sTask_, &sServerHost_, &nServerPort_, &sTaskURI_, &sPrivateTaskURI_);
   rem SQLExec("SELECT SERVER_HOST, SERVER_PORT, TASK_URI, PVT_TASK_URI FROM PS_SOMETHING WHERE AM_IOT_TASK = :1 AND AM_IOT_DFLT_INST = 'Y'", &sTask_, &sServerHost_, &nServerPort_, &sTaskURI_, &sPrivateTaskURI_); /* Always select default instance */
   If All(&sServerHost_) Then
      If All(&sPrivateTaskURI_) Then
         &sEndpointURL_ = &oConstantService_.sHTTPS_ | &sServerHost_ | ":" | &nServerPort_ | &sPrivateTaskURI_;
         %This.debug("");
         %This.debug("Endpoint URL : " | &sEndpointURL_);
         Return &sEndpointURL_;
      Else
         rem TASK not supported;
         %This.LogRequest(&sMethodName_ | " PeopleSoft DOES NOT support TASK.", "");
         Return "";
      End-If;
   Else
      rem IoT instance NOT defined;
      %This.LogRequest(&sMethodName_ | " No default IoT instance defined.", "");
      %This.debug("");
      %This.debug("No default IoT instance defined!");
      Return "";
   End-If;
   
end-method;

/* 
 * Create JsonParser Object 
 */
method objJsonParser
   /+ &content as String +/
   /+ Returns JsonObject +/
   
   Local JsonParser &parser = CreateJsonParser();
   Local boolean &status = &parser.Parse(&content);
   Local JsonObject &jObj = &parser.GetRootObject();
   Return &jObj;
   
end-method;

method PSCipher
   &oPSCipher_ = CreateJavaObject("psft.pt8.pshttp.PSCipher");
end-method;

method encodePassword
   /+ &password as String +/
   /+ Returns String +/
   Return &oPSCipher_.encodePassword(&password);
end-method;

method decodePassword
   /+ &password as String +/
   /+ Returns String +/
   Return &oPSCipher_.decodePassword(&password);
end-method;

/* 
 * Handle <orgId> substitution 
 */
method SubstituteURI
   /+ &sInputURI_ as String, +/
   /+ &sIoTOrgID_ as String +/
   /+ Returns String +/
   
   Local string &sSubstitutedURI_;
   If DBPatternMatch(&sInputURI_, &oConstantService_.IoTOrgPattern_, False) Then /* Case-insensitive pattern match */
      &sInputURI_ = Substitute(&sInputURI_, &oConstantService_.IoTOrgPattern_, &sIoTOrgID_);
      &sSubstitutedURI_ = &sInputURI_;
   Else
      &sSubstitutedURI_ = "";
   End-If;
   
   Return &sSubstitutedURI_;
end-method;

/* 
 * Integrate with DEFAULT IoT instance 
 */
method sendRequest
   /+ &sUrl_ as String, +/
   /+ &sAction_ as String, +/
   /+ &sRequest_ as String, +/
   /+ &bPatch_ as Boolean +/
   /+ Returns String +/
   
   Local string &sAuthInfo_, &sAuthHeader_, &sAuthEnc_, &sMethodName_;
   Local Message &oGenRspnsRESTMsg_, &oGenRqstRESTMsg_;
   &sMethodName_ = "JsonService:sendRequest";
   &oGenRqstRESTMsg_ = CreateMessage(Operation.IB_GENERIC_REST_POST); /* Use the delivered IB REST POST SvOp */
   
   Local IBInfo &IBInfo_ = &oGenRqstRESTMsg_.IBInfo;
   Local boolean &bRet = &IBInfo_.LoadConnectorProp("HTTPTARGET");
   &IBInfo_.ConnectorOverride = True;
   &IBInfo_.IBConnectorInfo.ConnectorClassName = "HttpTargetConnector";
   &IBInfo_.IBConnectorInfo.ConnectorName = "HTTPTARGET";
   
   REM Fetch UserID/Password from new config page. Password SHOULD have been encrypted with PSCipher;
   REM Password would need to be decrypted;
   Local string &sUserID_, &sDecodedPassword_, &sPassword_;
   SQLExec("SELECT USERID, password from " | Record.PSOPRDEFN | "WHERE 1 = 1", &sUserID_, &sPassword_);
   &sDecodedPassword_ = %This.decodePassword(&sPassword_);
   %This.debug("");
   %This.debug("Decoded Password : " | &sDecodedPassword_);
   &sAuthInfo_ = &sUserID_ | ":" | &sDecodedPassword_; /* This should ideally be hidden */
   /* DO NOT USE SUN PACKAGES
   &oString_ = CreateJavaObject("java.lang.String", &sAuthInfo_);
   &oEncoder_ = CreateJavaObject("sun.misc.BASE64Encoder");
   &sAuthEnc_ = &oEncoder_.encodeBuffer(&oString_.getBytes());
   &sAuthEnc_ = "Basic " | &sAuthEnc_;
   */
   REM The class currently supports BASIC Auth;
   &oHeader_ = CreateJavaObject("java.lang.String", &sAuthInfo_);
   &oEncoder_ = CreateJavaObject("com.peoplesoft.tools.util.Base64");
   &sAuthEnc_ = &oEncoder_.encode(&oHeader_.getBytes("UTF8"));
   &sAuthEnc_ = "Basic " | &sAuthEnc_;
   REM &sAuthEnc_ = %This.Base64AuthenticationHeader();
   rem Authorization: Basic base64-encoding of userid:password;
   &sAuthHeader_ = &sAuthEnc_;
   %This.debug("Authentication Header : " | &sAuthHeader_);
   rem &bRet = &IBInfo_.IBConnectorInfo.AddConnectorProperties("Authorization", "Basic " | &sAuthHeader_, %HttpHeader);
   &bRet = &IBInfo_.IBConnectorInfo.AddConnectorProperties("Authorization", &sAuthHeader_, %HttpHeader);
   &bRet = &IBInfo_.IBConnectorInfo.AddConnectorProperties("Content-Type", "application/json; encoding=""UTF-8""", %HttpHeader);
   If &bPatch_ Then
      &bRet = &IBInfo_.IBConnectorInfo.AddConnectorProperties("X-HTTP-Method-Override", "PATCH", %HttpHeader); /* V IMP */
   Else
      rem nothing to do;
   End-If;
   &bRet = &IBInfo_.IBConnectorInfo.DeleteConnectorProperties("URL");
   &bRet = &IBInfo_.IBConnectorInfo.AddConnectorProperties("URL", &sUrl_, %HttpProperty);
   &bRet = &IBInfo_.IBConnectorInfo.DeleteConnectorProperties("Method");
   rem &bRet = &IBInfo_.IBConnectorInfo.AddConnectorProperties("Method", "GET", %HttpProperty); /* Change this based on HTTP Verbs */
   &bRet = &IBInfo_.IBConnectorInfo.AddConnectorProperties("Method", &sAction_, %HttpProperty);
   
   Evaluate &sAction_
   When = "GET"
   When = "DELETE"
      rem &sRequest_ WILL BE BLANK, so ignore;
      Break;
   When = "POST"
   When = "PUT"
      If &sRequest_ <> "" Then
         &bRet = &oGenRqstRESTMsg_.SetContentString(&sRequest_);
      Else
         rem invalid request;
         %This.debug("JSON request payload is required for Action : " | &sAction_);
      End-If;
      Break;
   When-Other
      rem Action not supported;
      %This.debug("Action currently not supported : " | &sAction_);
      Break;
   End-Evaluate;
   
   try
      &oGenRspnsRESTMsg_ = %IntBroker.ConnectorRequest(&oGenRqstRESTMsg_, True); /* Response received from IoT */
      If &oGenRspnsRESTMsg_.ResponseStatus <> %IB_Status_Success Then
         throw &oGenRspnsRESTMsg_.IBException;
      End-If;
   catch Exception &eIoT_
      %This.printConsole("ERROR: " | &eIoT_.ToString());
      %This.printConsole("");
      %This.LogRequest(&sMethodName_ | " Exception Response: ", &oGenRspnsRESTMsg_.GetContentString());
      throw &eIoT_;
   end-try;
   
   If &oGenRspnsRESTMsg_ = Null Then
      REM create new message catalog for IoT Exceptions;
      rem throw CreateException(262, 2162, "Null Message in ES Response");
      %This.printConsole("ERROR: " | " NULL Message in IoT Response");
   End-If;
   
   Local string &sMsgContent_ = &oGenRspnsRESTMsg_.GetContentString();
   %This.LogRequest(&sMethodName_ | " Response: ", &sMsgContent_);
   
   If Len(&sMsgContent_) < 0 Then
      Return "";
   Else
      Return &sMsgContent_;
   End-If;
   
end-method;

method hmacAuthenticationHeader
   /+ &url as String, +/
   /+ &admnuser as String, +/
   /+ &admnpass as String, +/
   /+ &proxyuser as String, +/
   /+ &proxypass as String, +/
   /+ &serverurl as String +/
   /+ Returns String +/
   
   Local string &user, &password, &urlstring;
   If Right(&url, 7) = "_search" Then
      &user = &proxyuser;
      &password = &proxypass;
   Else
      &user = &admnuser;
      &password = &admnpass;
   End-If;
   &password = Decrypt("", &password);
   Local object &oByteStr = CreateJavaObject("java.lang.String", &password);
   Local object &signingKey = CreateJavaObject("javax.crypto.spec.SecretKeySpec", &oByteStr.getBytes("UTF8"), "HmacSHA256");
   Local object &mac = GetJavaClass("javax.crypto.Mac").getInstance("HmacSHA256");
   &mac.init(&signingKey);
   &url = Substitute(&url, &serverurl, "/");
   Local object &hmacbytes = &mac.doFinal(CreateJavaObject("java.lang.String", &url).getBytes("UTF8"));
   Local object &oEncoder = CreateJavaObject("com.peoplesoft.tools.util.Base64");
   Local string &authenc = &oEncoder.encode(&hmacbytes);
   &authenc = "hmac " | &user | ":" | &authenc;
   Return &authenc;
   
end-method;

method Base64AuthenticationHeader
   /+ Returns String +/
   
   Local string &user, &password, &admnuser, &admnpass, &proxyuser, &proxypass;
   SQLExec("SELECT PTSF_ADMIN_USRNAME, PTSF_ADMIN_PASSWD, PTSF_QRY_PROXY_USR, PTSF_QRY_PROXY_PWD FROM PS_PTSF_SRCH_ENGN WHERE PTSF_SRCH_ENG_INS = 'Y'", &admnuser, &admnpass, &proxyuser, &proxypass);
   
   Local object &header = CreateJavaObject("java.lang.String", &user | ":" | &password);
   Local object &oEncoder = CreateJavaObject("com.peoplesoft.tools.util.Base64");
   Local string &authenc = &oEncoder.encode(&header.getBytes("UTF8"));
   &authenc = "Basic " | &authenc;
   Return &authenc;
   
end-method;

method LogRequest
   /+ &function as String, +/
   /+ &request as String +/
   
   Local string &startMarking = "***START***";
   Local string &endMarking = "***END***";
   Local string &newStr = Char(13);
   Local integer &length = Len(&request);
   If &length < 4096 Then
      WriteToLog(%ApplicationLogFence_Error, &function | &request);
   Else
      /* 4096 - ( 256 * 2 ) */
      Local integer &segmentSize = 3586;
      Local integer &segmentCout = &length / &segmentSize;
      Local integer &segmentMod = Mod(&length, &segmentSize);
      Local integer &index = 0;
      Local string &segmentStr = "";
      Local integer &startPos = 1;
      For &index = 1 To &segmentCout Step 1
         &segmentStr = Substring(&request, &startPos, &segmentSize);
         WriteToLog(%ApplicationLogFence_Error, &function | "Part " | &index | " :" | &newStr | &startMarking | &segmentStr | &endMarking);
         &startPos = &startPos + &segmentSize;
      End-For;
      If &segmentMod <> 0 Then
         &index = &index + 1;
         &segmentStr = Substring(&request, &startPos, &segmentMod);
         WriteToLog(%ApplicationLogFence_Error, &function | "Part " | &index | " :" | &newStr | &startMarking | &segmentStr | &endMarking);
      End-If;
   End-If;
end-method;

method logPollSpanTime
   /+ &sMethodName_ as String, +/
   /+ &startTime_ as Time, +/
   /+ &endTime_ as Time +/
   
   %This.LogRequest("JsonService.logPollSpanTime : Method : " | &sMethodName_ | " Poll Time (ms)  ", NumberToString("%6.3", Value(&endTime_ - &startTime_)));
end-method;

method printConsole
   /+ &promptMessage as String +/
   
   Local JavaObject &out_ = GetJavaClass("java.lang.System").out;
   Local JavaObject &argTypes_ = CreateJavaObject("java.lang.Class[]", GetJavaClass("java.lang.String"));
   Local JavaObject &jMethod_ = &out_.getClass().getDeclaredMethod("println", &argTypes_);
   &jMethod_.invoke(&out_, CreateJavaObject("java.lang.Object[]", &promptMessage));
end-method;

method debug
   /+ &sText as String +/
   
   If &bDebug Then
      WriteToLog(%ApplicationLogFence_Error, &sText);
   End-If;
   
end-method;

method cleanURI
   /+ &sInputURI_ as String +/
   /+ Returns String +/
   Local string &sModURI_;
   
   Return &sModURI_;
end-method;
